## 事务的四大属性
1. 原子性
要么全部成功，要么全部失败
2. 一致性
状态变化必须一致，事务执行之前和执行之后状态一致
3. 隔离性
当多个用户并发访问数据库时，如果同时操作一张表时，数据库为每一个用户开启的事务，不能被其他事务所干扰，多个并发事务之间相互隔离
4. 持久性
事务一旦被提交，就是永久改变

### 事务的隔离级别

---
#### 为什么要设置隔离级别
在数据库操作中可能会出现几个问题（更新丢失、脏读、不可重复读、幻读）

##### 更新丢失
如果多个线程操作，基于同一个查询结构对表修改，后提交的事务会对前面提交的事务进行覆盖
* 第一类丢失更新：后提交的事务撤销了，并且对已经提交的事务进行了覆盖
* 第二类丢失更新：后提交的事务对先提交的事务数据进行覆盖
> 解决办法：
> 使用锁，只允许一个事务并发执行
##### 脏读
A事务读取B事务尚未提交的数据并在此基础上进行操作，B事务进行回滚，则A读脏数据
> 解决办法：
> 如果在一个事务提交之前，任何其他事务不可读取其修改过的值
##### 不可重复读
一个事务对同一行数据重复读两次，而另一个事务提交数据修改，则前后两次数据不一致
> 解决办法：
> 在事务完全提交之后才可以读取数据
##### 幻读
两次SELECT语句会出现不同的结果，第二次读会增加一行数据
有些时候幻读是我们需要的，有些时候却不是
比如打开的游标，对游标进行操作时，并不希望新增的数据到游标中
> 解决办法：
> 在操作事务完成数据处理之前，任何事务不可以添加新数据
---
#### 事务的隔离级别
|隔离级别|脏读|不可重复读|幻读|第一类丢失更新|第二类丢失更新|
|---|---|---|---|---|---|
|READ UNCOMMITED|允许|允许|允许|不允许|允许
|READ COMMITED|不允许|允许|允许|不允许|允许
|REPEATABLE READ|不允许|不允许|允许|不允许|不允许
|SERIALIZABLE|不允许|不允许|不允许|不允许|不允许
##### READ UNCOMMITED（未授权读取、读未提交）
1. 如果一个事务已经开始写数据，则其他事务不能进行写数据，但是可以进行读数据，可以通过排他锁实现
2. （脏数据）但是因为可以读数据，则一旦一个事务回滚了，则会读到脏数据
##### READ COMMITED（授权读取、读提交）
1. 读取的数据允许其他的事务进行读取，但是未提交的事务所涉及的行将会禁止其他事务进行读取。这样操作避免了脏读
2. 但是这样的操作却可能出现不可重复读，事务A读取数据，事务B更新数据提交事务，事务A再次读取时则数据前后不一致
##### REPEATABLE READ（可重复读取）
1. 可重复读是指在一个事务内，多次读取同一数据。在这个事务还没结束的时候，另一个事务也访问该同一数据。这样即使第二个事务修改数据也不会影响第一个事务的数据读取。
2. 读取数据的事务将会禁止写事务，写事务禁止任何其他事务。这样避免了不可重复读和脏读，但会出现幻像读
3. 读事务可以通过共享读锁和排他锁实现
##### SERIALIZABLE（序列化）
所有的事务将会严格隔离，序列化执行，一个接一个地执行，不能并发执行
> 序列化是最高级别地事务隔离
> 花费代价最高、性能最低
> 但是将会避免脏读、不可重复读和幻想读

---
隔离级别越高，越能保证数据地完整性和一致性，但是并发性和性能会下降。
* 对于大多数程序，可以将事务隔离级别设为READ COMMITED。避免脏读的同时也具有良好的并发性能。尽管会出现不可重复读、幻读和第二类更新丢失的问题，可以通过悲观锁和乐观锁来控制。MySQL默认REPEATABLE READ

---
### 乐观锁与悲观锁
#### 悲观锁
指的是对数据被外界修改持有保守态度。在整个数据处理中，数据将会处于锁定状态。
> 使用悲观锁必须要将MySQl数据库关闭自动提交属性。MySQL默认使用auto commit属性，当执行的一个更新操作，MySQL会立刻将结果提交。
```sql
set autocommit = 0;
```
比如原先的操作语句
```sql
select status from t_items where id = 1;
insert into t_orders (id, goods_id) values (null, 1);
update t_items set status = 2;
```
当执行第三步语句时，可能会出现别人先一步对商品下单把t_items的status修改为2了，这样会导致下单两次，数据不安全可靠
使用悲观锁
```sql
BEGIN;
SELECT status FROM t_items where id = 1 for update;
//这里for update就是使用了悲观锁，当执行完事务时才会放开
INSERT INTO t_orders (id, goods_id) VALUES (NULL, 1);
COMMIT;
```
> 注意一下，MySQL InnoDB中悲观锁默认为Row-Level Lock
> 当明确指定主键或者索引时，才会执行Row Lock
> 如果没有指定，将执行Table Lock，即锁住整张表，别人都不能访问

悲观锁看得出来，需要数据库的锁机制进行实现，并且如果长时间锁住，将会影响数据的并发性，对数据库性能开销很大，特别是长事务。于是衍生出了乐观锁

---
#### 乐观锁
乐观锁认为一般情况下，数据不会发生冲突，只有在数据进行提交更新的时候，才会正式对数据的冲突进行判断。如果冲突了，返回冲突信息，让用户自己做决定
* 使用版本号version
* 使用时间戳
两者都是在数据库表中插入一个数据，每次执行时都会更新。
当我们提交更新时，会将对应记录的版本和第一次取出来的版本进行比较，相等才允许更新，不相等就认为过期数据