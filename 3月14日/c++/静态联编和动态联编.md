### 静态联编和动态联编
程序调用函数时，将使用哪个代码块呢？
编译器负责回答这个问题
将源代码中的函数调用解释为执行特定的函数代码块被称为**函数名联编**
* 在c中很简单，因为一个函数对应一个代码块
* 在c++中就复杂了，因为函数重载的问题，所以编译器必须查看函数参数以及函数名才能确定使用哪个函数

然而，机智的c/c++编译器可以在编译过程中完成这种联编
在编译过程中的联编被称为**静态联编**

然而，虚函数的出现使得这项工作更难。
使用哪一个函数不是在编译时能确定的，因为编译器不知道用户会使用哪种对象
所以编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为**动态联编**

#### 指针和引用类型的兼容性
在c++中，动态联编与通过指针和引用调用方法有关，从某种程度而言，这是由继承控制的。
通常c++不允许将一种类型的地址赋给另一个类型的指针
```c++
double x = 2.5;
int* p = &x;//不允许这样
long* pl = &x;//不允许这样
```
然而，指向基类的引用或者指针可以引用派生类对象
```c++
BrassPlus dilly("Annie Dill", 493222, 2000);
Brass* pb = &dilly;
Brass& rb = dilly;
```
将派生类引用或指针转换为基类引用或指针被称为**向上强制转换**
BrassPluss都是Brass对象的，因为它继承了Brass对象所有的数据成员和成员函数

相反的过程，将基类指针或引用转换为派生类的指针或引用被称为**向下强制转换**
如果不适用显示类型转换，则向下强制转换是不允许的
因为可能会通过这个指针或引用来调用派生类的方法，这样是不安全的。

#### 虚成员函数和动态联编
```c++
BrassPlus opheliaa;
Brass* bp;
bp = &ophelia;
bp->ViewAcct();
```
如果在基类中没有将ViewAcct方法声明为虚，则bp->ViewAcct()将调用Brass::ViewAcct()。指针类型是在编译时已知，因此编译器在编译时，可以将ViewAcct()关联到Brass::ViewAcct()。总之，编译器对非虚方法使用静态联编。

然而，如果在基类中将ViewAcct方法声明为虚，则bp->ViewAcct()将根据bp指向的类型(BrassPlus)使用BrassPlus::ViewAcct()。通常，只有在运行程序时才能确定对象的类型。所以编译器对虚方法使用动态联编

---
#### 你可能会有以下疑问：
* 为什么会有两种类型的联编并且为什么默认为静态联编
* 既然动态联编如此之好，不将其设置为默认的？
  答：
  > 原因有两个，效率和概念模型
  1. 效率
    为使程序在运行阶段决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型。这会增加额外的处理开销
    如果类不需要用作基类，或者派生类不需要重新定义基类的任何方法，则不需要动态联编，使用静态联编更合理且更有效率。
    所以默认使用静态联编，会让程序更有效率。c++的指导原则就是不要为不使用的特性付出代价（空间或时间）
  2. 概念模型
    在设计类时，可能包含一些不在派生类重新定义的成员函数。
    所以不将其定义为虚函数，可以效率更高，并且可以指明意图。
    ---
* 动态联编是如何工作的
* 虚函数的工作原理
  答：
  > * 编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组被称为**虚函数表**（vtbl）。
  > * **虚函数表中**存储了为类对象进行声明的虚函数的地址。

  回顾一下，函数指针，例如：int (*p)(int, int)

  例如：
  基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。
  1. 如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址
  2. 如果派生类没有重新定义虚函数，则该vtbl将保存函数原始版本的地址。
  3. 如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中。
  > 无论类中有多少个虚函数，都只需要在对象中添加一个地址成员，只是表的大小不同而

  调用虚函数时，程序将查看存储在对象中的vtbl地址，然后转向相应的函数地址表。
  如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。同理

  ---
  使用虚函数时，在内存和执行速度方面有一定的成本：
  * 每个对象都将增大，增大量为存储地址的空间
  * 对于每个类，都将创建一个虚函数地址表
  * 对于每个类的调用，都将执行一项额外的操作，也就是到表中查找地址
  虽然非虚函数的效率更高，但是并不具备动态联编功能

#### 有关虚函数的注意事项
1. 构造函数
   构造函数不能是虚函数。
   创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，
   然后派生类的构造函数将使用一个基类的构造函数。
   
   ---
2. 析构函数
   析构函数应当是虚函数，除非类不当基类。
   假设Employee是基类，Singer是派生类，添加一个char* 成员，该成员指向由new分配的内存。
   ```c++
   Employee* pe = new Singer;
   ...
   delete pe;
   ```
   如果使用的是静态联编，则delete语句将会调用~Employee析构函数。这将会释放Singer对象中的Employee部分指向的内存，
   但不会释放新的类成员的内存。
   通常给基类提供一个虚析构函数，即便它不需要析构函数
   > 给类定义一个虚函数不会有任何问题，只是效率方面要差点，毕竟动态联编

   ---
3. 友元
   友元不能是虚函数，因为友元不是类成员，只有成员才能是虚函数。
   如果有设计上面的问题，可以让友元来使用虚函数解决。

   ---
4. 没有重新定义
   如果派生类没有重新定义，将使用该函数的基类版本。如果派生类位于派生链中，将使用最新的虚函数版本。除非虚函数是隐藏的。

   ---
5. 重新定义将隐藏方法
    ```c++
    class Dwelling
    {
    public:
        virtual void showperks(int a) const;
    };
    ...
    class Hovel : public Dwelling
    {
    public:
        virtual void showperks() const;
    }
    ```
    这将导致问题，也有可能不出现警告
    所以以下代码会变样
    ```c++
    Hovel trump;
    trump.showperks(); //允许
    trump.showperks(5); //不允许
    ```
    重新定义不会生成函数的两个重载版本，而是会隐藏了一个接受int参数的版本。总之，重新定义继承的方法并不是重载。如果重新定义派生类中的函数，将不只是使用相同参数的函数参数列表覆盖基类声明，无论参数列表是否相同，该操作将会隐藏所有的同名基类方法。
    
    ---
    所以，有两条规则：
    1. 如果重新定义继承的方法，一定要确保与原来的原型相同。如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这被称为**返回类型协变**
    > 这种只适用于返回值，不适用于参数
    2. 如果类声明被重载了，则应在派生类中重新定义所有的基类版本。
   ```c++
   class Dwelling
   {
    public:
        virtual void showperks(int a) const;
        virtual void showperks(double x) const;
        virtual void showperks() const;
   };

   class Hovel : public Dwelling
   {
        virtual void showperks(int a) const;
        virtual void showperks(double x) const;
        virtual void showperks() const;
   };
   ```
   如果只定义一个版本，则其它两个版本会被隐藏，派生类对象将无法使用。
   当让，如果不需要修改，可以直接这样写
   ```c++
   void Hovel::showperks() const{ Dwelling::showperks();}
   ```